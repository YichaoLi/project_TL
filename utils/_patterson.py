#==================================================================================================
#
# Integration using Patterson quadrature rules using numpy vectorized routines
#
#==================================================================================================
# patterson formulae & integration
# Integral_-1^1 f(x) dx = f(0)+Sum _1^order w[i]*(f(0-x[i])+f(0+x[i]))
#==================================================================================================
# Author: J. Chluba, April 2011
#==================================================================================================

import math
import numpy as np

#==================================================================================================
# List of weights and abscissae for each level of refinement 'p'
#==================================================================================================
Patterson_iteration = np.array([1, 3, 7, 15, 31, 63, 127, 255])

#==================================================================================================
# order 3
#==================================================================================================
Patterson_x3 = np.array([0.7745966692414834])

Patterson_w3 = np.array([0.8888888888888888, 0.5555555555555556])

#==================================================================================================
# order 7
#==================================================================================================
Patterson_x7 = np.array([0.4342437493468025, 0.9604912687080203])

Patterson_w7 = np.array([0.4509165386584741, 0.4013974147759622,
                         0.2684880898683334, 0.1046562260264673])
                      
#==================================================================================================
# order 15
#==================================================================================================
Patterson_x15 = np.array([0.2233866864289669, 0.6211029467372264,
                          0.888459232872257, 0.993831963212755])
                       
Patterson_w15 = np.array([
    0.2255104997982067, 0.2191568584015875, 0.200628529376989, 0.1715119091363914,
    0.1344152552437842, 0.09292719531512454, 0.05160328299707974, 0.01700171962994026
    ])
    
#==================================================================================================
# order 31
#==================================================================================================
Patterson_x31 = np.array([
    0.1124889431331866, 0.3311353932579768, 0.5313197436443756, 0.7024962064915271,
    0.8367259381688688, 0.9296548574297401, 0.9815311495537401, 0.9990981249676676
    ])

Patterson_w31 = np.array([
    0.1127552567207687, 0.1119568730209535, 0.1095784210559246, 0.1056698935802348, 
    0.1003142786117956, 0.09362710998126447, 0.08575592004999034, 0.07687962049900353, 
    0.0672077542959907, 0.05697950949412336, 0.04646289326175799, 0.03595710330712932,
    0.02580759809617665, 0.01644604985438781, 0.008434565739321106, 0.002544780791561875
    ])

#==================================================================================================
# order 63
#==================================================================================================
Patterson_x63 = np.array([
    0.05634431304659279, 0.1682352515522075, 0.2777498220218243, 0.3833593241987304, 
    0.4836180269458411, 0.5771957100520458, 0.6629096600247806, 0.7397560443526947, 
    0.8069405319502176, 0.8639079381936905, 0.9103711569570043, 0.9463428583734029, 
    0.9721828747485818, 0.9886847575474295, 0.997206259372222, 0.9998728881203576
    ])

Patterson_w63 = np.array([
    0.05637762836038471, 0.0562776998312543, 0.05597843651047632, 0.05548140435655936, 
    0.05478921052796287, 0.05390549933526606, 0.05283494679011652, 0.05158325395204846, 
    0.05015713930589954, 0.0485643304066732, 0.04681355499062801, 0.0449145316536322, 
    0.04287796002500773, 0.04071551011694432, 0.03843981024945553, 0.03606443278078257, 
    0.03360387714820773, 0.03107355111168797, 0.02848975474583355, 0.02586967932721475, 
    0.02323144663991027, 0.02059423391591271, 0.01797855156812827, 0.0154067504665595, 
    0.01290380010035127, 0.01049824690962132, 0.00822300795723593, 0.006115506822117246, 
    0.004217630441558855, 0.002579049794685688, 0.001265156556230068, 0.0003632214818455306
    ])

#==================================================================================================
# order 127
#==================================================================================================
Patterson_x127 = np.array([
    0.02818464894974569, 0.08445404008371088, 0.1404242331525602, 0.1958975027111002, 
    0.2506787303034832, 0.304576441556714, 0.3574038378315322, 0.4089798212298887,    
    0.4591300119898323, 0.5076877575337166, 0.5544951326319325, 0.5994039302422429, 
    0.6422766425097595, 0.6829874310910792, 0.7214230853700989, 0.7574839663805136,     
    0.7910849337998483, 0.8221562543649804, 0.8506444947683502, 0.8765134144847053, 
    0.8997448997769401, 0.9203400254700124, 0.9383203977795929, 0.9537300064257611,     
    0.9666378515584165, 0.9771415146397057, 0.9853714995985203, 0.9914957211781061, 
    0.9957241046984072, 0.9983166353184074, 0.9995987996719107, 0.9999824303548916  
    ])

Patterson_w127 = np.array([
    0.02818881418019236, 0.0281763190330166, 0.02813884991562715, 0.02807645579381725, 
    0.02798921825523816, 0.0278772514766137, 0.02774070217827968, 0.02757974956648187,   
    0.02739460526398143, 0.02718551322962479, 0.02695274966763303, 0.02669662292745036, 
    0.02641747339505826, 0.0261156733767061, 0.02579162697602423, 0.02544576996546477,  
    0.02507856965294977, 0.02469052474448768, 0.0242821652033366, 0.02385405210603854, 
    0.02340677749531401, 0.02294096422938775, 0.0224572658268161, 0.02195636630531782,   
    0.02143898001250387, 0.02090585144581202, 0.02035775505847216, 0.0197954950480975, 
    0.01921990512472777, 0.01863184825613879, 0.01803221639039129, 0.01742193015946417,  
    0.01680193857410386, 0.01617321872957772, 0.01553677555584398, 0.01489364166481518, 
    0.01424487737291678, 0.01359157100976555, 0.01293483966360737, 0.01227583056008277,     
    0.01161572331995513, 0.0109557333878379, 0.01029711695795636, 0.009641177729702537, 
    0.008989275784064136, 0.008342838753968157, 0.007703375233279742, 0.007072489995433555,     
    0.006451900050175737, 0.00584344987583564, 0.005249123454808859, 0.004671050372114322, 
    0.004111503978654693, 0.003572892783517299, 0.003057753410175531, 0.00256876494379402,   
    0.002108815245726633, 0.00168114286542147, 0.001289524082610417, 0.0009383698485423815, 
    0.0006326073193626335, 0.0003777466463269846, 0.0001807395644453884, 5.053609520786252e-05  
    ])

#==================================================================================================
# order 255
#==================================================================================================
Patterson_x255 = np.array([
    0.01409388641078246, 0.0422691647653636, 0.07040697604285517, 0.09848239659811921, 
    0.126470584372302, 0.1543468114813781, 0.1820864967592522, 0.2096652382431812, 
    0.2370588455898297, 0.2642433724109268, 0.2911951485182467, 0.3178908120684767, 
    0.344307341599438, 0.3704220879500782, 0.3962128060576159, 0.4216576866261633, 
    0.4467353876620285, 0.4714250658716589, 0.4957064079187615, 0.519559661537457, 
    0.5429656664983115, 0.5659058854236544, 0.5883624344476626, 0.6103181137151864, 
    0.6317564377111943, 0.6526616654100175, 0.6730188302304185, 0.6928137697791147, 
    0.712033155362252, 0.7306645212421813, 0.7486962936169366, 0.7661178193037601, 
    0.782919394118283, 0.7990922909608414, 0.8146287876551375, 0.8295221946374014, 
    0.8437668826727086, 0.8573583108862322, 0.8702930555481139, 0.8825688402473419, 
    0.894184568335559, 0.9051403588132616, 0.9154375871557651, 0.9250789329070757, 
    0.9340684361577258, 0.942411565191083, 0.9501152975212949, 0.9571882161098609, 
    0.9636406215698121, 0.9694846595024592, 0.9747344597524027, 0.9794062816708626, 
    0.9835186575786328, 0.987092527954034, 0.9901513704007702, 0.9927213442827886, 
    0.994831502800621, 0.9965141459148903, 0.9978053544959573, 0.9987456144680951, 
    0.9993803380250236, 0.9997604909244321, 0.9999439962070544, 0.9999975963797485
    ])

Patterson_w255 = np.array([
    0.01409440709009618, 0.01409284506916041, 0.0140881595165083, 0.01408035196255366, 
    0.01406942495781358, 0.01405538207264996, 0.01403822789690862, 0.01401796803945661, 
    0.01399460912761908, 0.01396815880651694, 0.01393862573830685, 0.01390601960132546, 
    0.01387035108913984, 0.01383163190950643, 0.01378987478324094, 0.0137450934430019, 
    0.01369730263199072, 0.01364651810257129, 0.0135927566148124, 0.01353603593495621, 
    0.01347637483381652, 0.0134137930851101, 0.01334831146372518, 0.01327995174393053, 
    0.01320873669752913, 0.01313469009196015, 0.01305783668835305, 0.0129782022395374, 
    0.01289581348801211, 0.01281069816387736, 0.01272288498273238, 0.01263240364354208, 
    0.01253928482647488, 0.01244356019071404, 0.01234526237224384, 0.01224442498161199, 
    0.0121410826016683, 0.01203527078527956, 0.01192702605301927, 0.01181638589083024, 
    0.011703388747657, 0.01158807403304395, 0.01147048211469387, 0.0113506543159806, 
    0.01122863291340805, 0.01110446113400693, 0.01097818315265891, 0.01084984408933731, 
    0.01071949000625193, 0.0105871679048852, 0.01045292572290601, 0.01031681233094762, 
    0.01017887752923608, 0.01003917204405684, 0.009897747524048749, 0.009754656536317411, 
    0.009609952562363883, 0.009463689993830066, 0.009315924128069395, 0.009166711163560789, 
    0.009016108195195643, 0.008864173209482495, 0.008710965079732087, 0.008556543561307689, 
    0.008400969287051932, 0.008244303763032867, 0.00808660936478886, 0.007927949334294849, 
    0.007768387777921991, 0.007607989665719056, 0.007446820832407591, 0.007284947980553807, 
    0.007122438686458388, 0.006959361409390423, 0.006795785504882773, 0.006631781242901888, 
    0.006467419831803687, 0.006302773449085758, 0.006137915280041385, 0.005972919565508166, 
    0.005807861659977567, 0.005642818101384444, 0.005477866693918951, 0.005313086605187057, 
    0.005148558478978178, 0.004984364564765539, 0.004820588864851269, 0.004657317299756855, 
    0.004494637892032068, 0.004332640968092983, 0.004171419376984078, 0.004011068724075023, 
    0.003851687616639871, 0.003693377917025651, 0.003536244997716778, 0.00338039799108692, 
    0.003225950025087868, 0.003073018434702578, 0.00292172493791782, 0.002772195764593451, 
    0.00262456172740443, 0.002478958226657568, 0.002335525186057161, 0.002194406925363839, 
    0.002055751989327346, 0.001919712971013872, 0.00178644639175865, 0.001656112728154453, 
    0.001528876705087765, 0.001404907995655145, 0.00128438247189701, 0.001167484117429959, 
    0.001054407622863317, 0.0009453615168585254, 0.0008405714327107224, 0.0007402828042445033, 
    0.0006447620413057248, 0.0005542953149303748, 0.0004691849242478504, 0.0003897452844732823, 
    0.0003163036608222645, 0.0002492124004829973, 0.0001888732645065049, 0.0001357549109492287, 
    9.037273465875115e-05, 5.327529366978061e-05, 2.515787038428066e-05, 6.937936432410826e-06 
    ])



#==================================================================================================
#
# Functions to compute the integral
#
#==================================================================================================
def compute_integral_function_Patterson(order, xc, Dx, f, fvals):

    neval=0
    r=0.0

    #==============================================================================================
    # decide which rule to use
    #==============================================================================================
    if   order==3:   x=Patterson_x3;   w=Patterson_w3;   nx=1;
    elif order==7:   x=Patterson_x7;   w=Patterson_w7;   nx=2;
    elif order==15:  x=Patterson_x15;  w=Patterson_w15;  nx=4;
    elif order==31:  x=Patterson_x31;  w=Patterson_w31;  nx=8;
    elif order==63:  x=Patterson_x63;  w=Patterson_w63;  nx=16;
    elif order==127: x=Patterson_x127; w=Patterson_w127; nx=32;
    elif order==255: x=Patterson_x255; w=Patterson_w255; nx=64;
    else:
        print ' compute_integral_function_Patterson:: too many points requested' 
        return r, fvals, neval, 1 
    #==============================================================================================
    
    #==============================================================================================
    # allocate new memory
    #==============================================================================================
    loc_vals = np.zeros(fvals.size+nx)
    
    #==============================================================================================
    # copy old values
    #==============================================================================================
    loc_vals[0:2*nx:2]=fvals[:]
        
    #==============================================================================================
    # evalutation of function at given abscissae
    #==============================================================================================
    loc_vals[1:2*nx:2] = f(xc+Dx*x) + f(xc-Dx*x)

    #==============================================================================================
    # compute integral; start with smallest terms first
    #==============================================================================================
    r = np.add.reduce(loc_vals*w)
    neval=2*order-1
    
    return Dx*r, loc_vals, neval, 0
    
    
    
#==================================================================================================
#
# Integral using Patterson formulae
#
#==================================================================================================
def Integrate_using_Patterson(a, b, eps, abs, f):

    r=0.0
    neval=0
    
    if a>=b: return r, neval, 2
    
    xc=(a+b)/2.0
    Dx=(b-a)/2.0
    
    fvals = np.zeros(1)
    fvals[0] = f(xc)

    #----------------------------------------------------------------------------------------------
    # Integral for 1-point formula
    #----------------------------------------------------------------------------------------------
    r=2.0*fvals[0]*Dx
    neval=1
    
    for it in range(1, 8):
    
        npoint=Patterson_iteration[it]
        
        r1, fvals, nv, ifail = compute_integral_function_Patterson(npoint, xc, Dx, f, fvals)
        
        if ifail!=0: return 0.0, 0, 2
        
        neval+=nv
        Dr=r-r1
        r=r1
        
        #==========================================================================================
        # check error
        #==========================================================================================
        if math.fabs(Dr) <= max(abs, math.fabs(r)*eps): return r, neval, 0
    
    return r, neval, 1           



#==================================================================================================
#
# Integral using Patterson formulae (refinement of regions)
#
#==================================================================================================
def Integrate_Patterson_refine(reclev, a, b, eps, abs, f):

    r = 0.0
    reclev_loc = reclev
    reclev_loc = reclev_loc + 1
        
    #==============================================================================================
    # to avoid SEGfault for strange integrands
    #==============================================================================================
    if reclev_loc>=100 :

        print ' Integrate_Patterson_refine::recursion_level has exceeded limit of 100.'
        print ' Exiting ' 
        raise Exception("Not converged.")
    
    #==============================================================================================
    ntot=0
    ifail=0
    subint=2
    b1=a 
    fa=(b-a)/subint
    
    #==============================================================================================
    for k in range(1, subint+1):

        a1=b1 
        b1=a1+fa 
        err = max(abs, math.fabs(r)*eps)
        
        r1, neval, ifail = Integrate_using_Patterson(a1, b1, eps, err, f)
        ntot+=neval
        
        #==========================================================================================
        # do subdivision (recursive calling)
        #==========================================================================================
        if ifail!=0:

            r1, neval, reclev_loc, ifail = Integrate_Patterson_refine(reclev_loc, a1, b1, eps, err, f) 
            ifail=0 
            ntot+=neval
        
        r+=r1

    #==============================================================================================
    return r, ntot, reclev_loc, ifail
       



#==================================================================================================
#
# Patterson quadrature rules
#
#==================================================================================================
def Integrate_Patterson(f, a, b, eps = 1e-10, abs = 1e-60, args = ()):

    if a>=b: return 0.0

    fx = lambda x: f(x, *args)
    
    ntot=0
    reclev = 0
    
    #==============================================================================================
    r, neval, ifail = Integrate_using_Patterson(a, b, eps, abs, fx)
    ntot+=neval
        
    #==============================================================================================
    # do subdivision if needed
    #==============================================================================================
    if ifail!=0:
        
        r, neval, reclev, ifail = Integrate_Patterson_refine(reclev, a, b, eps, abs, fx)
        ntot+=neval
        
    #==============================================================================================
    return r, ntot, ifail

